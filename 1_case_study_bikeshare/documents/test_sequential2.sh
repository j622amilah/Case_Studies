#!/bin/bash




clear



create_file_list(){

    # Inputs:  
    # None
    
    # Get list of all csv files in current directory, avoid files generated by program
    ls | sed 's/colBvalue//g' | sed 's/diffrow//g' | sed 's/diff//g' | sed 's/dummy_name//g' | sed 's/file0//g' | sed 's/file1//g' | sed 's/file2//g' | sed 's/file3//g' | sed 's/file4//g' | sed 's/file5//g' | sed 's/file_list//g' | sed 's/filetemp_reevaluate//g' | sed 's/filetemp//g' | sed 's/header2reevaluate_per_row//g' | sed 's/header2//g' | sed 's/header_match_count_per_file//g' | sed 's/header_reduced//g' | sed 's/modelscores//g' | sed 's/new_csv//g' | sed 's/result//g' | sed 's/rows_that_repword_appear//g' | sed 's/sim_float//g' | sed 's/sim_int//g' | sed 's/tempcount//g' | sed 's/to_replace_assignment//g' | sed 's/tot_headerreevaluate_per_row//g' | sed 's/uqtemp//g' | sed 's/test.sh//g' | sed 's/test2.sh//g' | sed 's/test3.sh//g' | sed 's/test4.sh//g' | sed 's/temp//g' | sed 's/tot_header//g' | sed 's/primary_key_list//g' | sed 's/no_match_header//g' | sed 's/test//g' | sed 's/count//g' | sed '/^$/d' > file_list
    
    echo "-----------------------------------"
    echo "file_list:"
    cat file_list
    echo "-----------------------------------"
    
    # ***** OUTPUT [file_list] *****
}


# ---------------------------





# Step 1: Get main path
export cur_path=$(pwd)
echo "cur_path"
echo $cur_path

export folder_2_organize=$(echo "bike_casestudy/csvdata_test")
echo "folder_2_organize"
echo $folder_2_organize

# Step 2: Get path of folder to search
export main_path=$(echo "${cur_path}/${folder_2_organize}")
echo "main_path"
echo $main_path

cd $main_path
    
    



# [Step 9] Calculate the primary key [one of words in tot_header] with respect to all the csv files

# Redo file_list, because it is missing one file
create_file_list




# ---------------------------
# Select [primary key] : Find the percentage of which tot_header words are present across all csv files. If there are equivalently used tot_header words, pick the tot_header word with the shortest length of characters per csv file.
# ---------------------------
export n_tot_header=$(cat tot_header | wc -l)
echo "n_tot_header: "
echo $n_tot_header


# Create a large length value as a filler
export dummy_len=$(echo "500")

# -------------
# Way 0
# echo "" > matrix_c
# echo "" > matrix_l

# Way 1
# export matrix_l=$(echo "")

# Way 2
for r in $( seq 1 $n_tot_header )
do
	tot_count[$r]=$(echo "0")
	tot_length[$r]=$(echo $dummy_len)
done

echo "tot_count"
echo ${tot_count[@]}

echo "tot_length"
echo ${tot_length[@]}
# -------------




export n=$(cat file_list | wc -l)
# echo "n: "
# echo $n

for filerow in $( seq 1 $n )
do
  # export filename=$(echo "202005-divvy-tripdata.csv")
  export filename=$(cat file_list | head -n $filerow | tail -n $(($filerow-($filerow-1))))
  

  # Get the header from the current csv
  cat $filename | head -n 1 | tr "," '\n' | tr -d '\r' > tempheader2
  cat tempheader2 | paste -s -d "," | sed 's/,/|,|/g' | sed 's/^/|/g' | sed 's/$/|/g' | tr "," '\n' | tr -d '\r' > tempheader2_bars
  
  
  export n_rows_filename=$(cat $filename | wc -l)
  export n_samples=$(echo "50") # random number of samples
  # echo "n_samples: "
  # echo $n_samples
  
  
  # if [ -f count ]; then
  #   rm count
  # fi
  
  # -------------
  # Way 0
  # if [ -f length ]; then
  #   rm length
  # fi
  
  # Way 1
  # unset out
  # -------------
  
  
  
  
  
  for r in $( seq 1 $n_tot_header )
  do
    echo "r:"
    echo $r
  
    # add bars to define the word
    export genheader_bars1=$(cat tot_header | head -n $r | tail -n $(($r-($r-1))) | tr -d '\r' | sed 's/^/|/g' | sed 's/$/|/g')
    # echo "genheader_bars1:"
    # echo $genheader_bars1

    # Count fixed strings (-F) from a file per line
    export loc_in_curheader=$(grep -n -F $genheader_bars1 tempheader2_bars)
    # echo "loc_in_curheader:"
    # echo $loc_in_curheader



    if [ ! -f $loc_in_curheader ]; then
      
      # Calculate the min character length for this column
      # Need to find the search_pattern in $filename, to get the column number
      if [ -f len_filename ]; then
        rm len_filename
      fi
      
      export colval=$(echo $loc_in_curheader | cut -d ':' -f 1)
      # echo "colval:"
      # echo $colval
      
      # ---------------------------
      for rf in  $(seq 1 $n_samples)
      do
        # $RANDOM is distributed between 0 and 32767
        # random selection between 2 and n_rows_filename
        export rand=$(echo "((($RANDOM + $RANDOM) % $n_rows_filename+1) + 2)" | bc)
        # echo "rand:"
        # echo $rand
        
        cat $filename | head -n $rand | tail -n $(($rand-($rand-1))) | tr -d '\r' | cut -d ',' -f $colval | tr -d '\n' | wc -m >> len_filename
      done   # END OF [for rf in  $( seq 1 $n_samples )]
      # ---------------------------
      
      export min_len=$(cat len_filename | sort -n | head -n 1)
      echo "min_len:"
      echo $min_len
      
      rm len_filename
      
      # Way 0: Save count and length value to file
      # echo 1 >> count
      # echo $min_len >> length
      # Problem: The file length is erased and it is not my program, it worked yesterday, concatenation is done by row instead of column
      
      # Way 1: put in string list
      # if [[ $r -eq 1 ]]; then
          # export out=$(echo $out[$r]$min_len)
      #   export out=$(echo $out$r.$min_len)
      # else
      #   export out=$(echo $out","$r.$min_len)
      # fi
      # Problem: can not search the brackets correctly around each index
      
      
      
      # Way 2: use an array
      if [[ $r -eq "1" ]]; then
      	count=("1")
      	length=("$min_len")
      elif [[ $r -eq $n_tot_header ]]; then 
	count=("${count[@]}" "1")
      	length=("${length[@]}" "$min_len")
      	
      	# Update array 
      	tot_length + count
      	
      	
      else
      	count=("${count[@]}" "1")
      	length=("${length[@]}" "$min_len")
      fi
      
      
    else
    
      # No match found, insert null column
      # Way 0: Save count and length value to file
      # echo 0 >> count
      # echo "" >> length
      
      # Way 1: put in string list
      # if [[ $r -eq 1 ]]; then
      #   export out=$(echo $out"$r.")
      # else
      #   export out=$(echo $out",$r.")
      # fi
      
      # Way 2: use an array
      if [[ $r -eq "1" ]]; then
      	count=("0")
      	length=("$dummy_len")
      else
      	count=("${count[@]}" "0")
      	length=("${length[@]}" "$dummy_len")
      fi
      
    fi  # END OF [if [ ! -f $loc_in_curheader ]; then]
    
    
    echo "out inside for loop:"
    echo $out
    
    
    
  done  # END of [for r in $( seq 1 $n_tot_header )]
  
  echo "out AFTER for loop:"
  echo $out
  
  

  # Count 
  # if [[ $c -eq 1 ]]; then
  #   paste matrix_c count -d "" >> matrix_c_temp
  # else
  #   paste matrix_c count -d "+" >> matrix_c_temp
  # fi
  # Problem : matrix_c_temp concatenates both columns as rows - Dislike that I can not concatenate columns


done    # END of [for r in $( seq 1 $n )]









